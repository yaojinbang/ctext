#include "head.h"
/*
1.冯诺依曼结构 
输入设备 键盘 硬盘
输出设备  显示器
内存
CPU
过程 就是从硬盘读取程序到内存中 通过内存和CPU之间的读写操作 最后将效果输出到显示器上
(运算器 控制器 存储器 输入设备 输出设备)

2.在win中， 双击的本质就是运行程序，将程序加载到内存中

3.任何程序在被运行之前都必须被加载到内存当中

4.所有的变量 本质上都是要在内存中开辟空间的 CPU在处理数据时并不会立刻处理所有数据 所以就需要用变量来暂时存放数据

5.定义：开辟空间

6.声明：告知 

7.全局变量：在所有函数外定义的变量 叫做全局变量

8.用花括号{}起来的区域叫做代码块 在代码块内定义的变量叫做局部变量

9.生命周期的概念 指的是该变量从定义到被释放的时间范围，所谓的释放，指的是曾经开辟的空间“被释放”
   局部变量：进入代码块，形成局部变量（开辟空间），退出代码块，“释放”局部变量
   全局变量：定义完成之后，程序运行的整个生命周期内，该变量一直都有效

10. 作用域 ：该变量的有效区域/影响的范围   生存周期：生存的时间

11.auto:一般修饰局部变量  局部变量又称 自动变量 临时变量 

12. 寄存器 cache(高速缓存) 内存 （硬盘、SSD、flash 磁带 光盘）
离CPU越近的存储单元，效率越高，单价成本越高
离CPU越远的存储单元，效率越低，单价成本越低

13.硬盘可以通过缓存技术将数据存到内存中

14.任何一种硬件而言，充当上游硬件的缓存

15.CPU访问数据的时候，以最小的成本，达到最高效率

16.一个变量如果被register修饰 就无法进行取地址操作
 1.局部变量（全局变量会导致CPU的寄存器被长期占用）
 2.不会被写入（写入就需要写回内存，后续还要读取检测）
 3.高频被读取的（提高效率所在）
 4.如果要使用，请不要大量使用，因为寄存器的数量有限

尽量将变量定义到寄存器中，从而达到提高效率的目的 
*/
// int main()
// {
//     printf("Hello World!\n");
//     return 0;
// }

// int g_val = 100;

// int main()
// {
//     int g_val = 200;//全局变量和局部变量命名冲突时，优先局部变量
//     printf("%d",g_val);
//     return 0;

// }

// int main()
// {
//     for(int i = 0; i<10; i++)
//     {
//         printf("i = %d\n", i);
//         if(1)
//         {
//             int j = 1;
//             printf("before: %d\n", j);
//             j++;
//             printf("after : %d\n", j);
//         }
//     } 
//     return 0;
// }

// int main()
// {
//    register int pass = 100;
//    int* pp = &pass;
//    printf("%d",*pp);
//    return 0;
// }
// extern void fun1();
// void fun()
// {
//    static int a = 0;
//    printf("%d\t",++a);
// }

// int main()
// {
//    int i = 0;
//    for(int i = 1; i<=5; i++)
//    {
//       fun();
//       fun1();
//    }
//    return 0;
// }

/*

声明是不开辟空间的
=100 ，叫做赋值或叫做初始化
所有的变量声明的时候，不能设置初始值！

函数在不声明的情况下也可以正常使用(不建议) 全局变量则不行 需要进行声明

static 修饰全局变量，该变量只在本文件内被访问，不能被外部其他文件直接访问 但可以间接访问
static 修饰函数，该函数只能在本文件内被访问，不能在外部其他文件直接访问
static 修饰局部变量，更改该局部变量的生命周期 临时变量->全局生命周期 作用域不变
*/


// int main()
// {
//    // g_val = 1;
//    printf("%d\n", g_val);
//    fun1();
//    return 0;
// }

// int* p = NULL;
// static void fun()
// {
//    static int a = 0;
//    p = &a;
//    printf("%p\t",&a);
//    printf("%d\n",++a);
// }
// int main()
// {
//    for(int i = 0; i<5; i++)
//    {
//       fun();
//    }
//    printf("%d", *p);
//    return 0;
// }
#define OFFSETOF(val,type)  (int)(&((type*)0)->val)
extern int g_val;

struct S
{
   char c1;//1
   int a;//4
   char c2;//1
};

int main()
{
   printf("%d",sizeof(struct S));
   printf("%d",g_val);
   printf("%d",OFFSETOF(a,struct S));
   return 0;
}

/*
栈区(向下)

堆区(向上)

未初始化全局
初始化全局
静态数据区   
code

称为c程序地址空间（操作系统的进程地址空间）
*/